[{"fullname": "SLIX", "modulename": "SLIX", "qualname": "", "type": "module", "doc": "<p>Module docstring text</p>\n"}, {"fullname": "SLIX._CPU.toolbox", "modulename": "SLIX._CPU.toolbox", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "SLIX._CPU.toolbox.background_mask", "modulename": "SLIX._CPU.toolbox", "qualname": "background_mask", "type": "function", "doc": "<p>Creates a background mask by setting all image pixels with low scattering\nsignals to zero. As all background pixels are near zero for all images in\nthe SLI image stack, this method should remove most of the background\nallowing for better approximations using the available features.\nIt is advised to use this function.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Complete SLI measurement image stack as a 2D/3D Numpy array\n\nthreshold: Threshhold for mask creation (default: 10)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>numpy.array: 1D/2D-image which masks the background as True and\n             foreground as False\n</code></pre>\n", "parameters": ["image", "threshold"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.peaks", "modulename": "SLIX._CPU.toolbox", "qualname": "peaks", "type": "function", "doc": "<p>Detect all peaks from a full SLI measurement. Peaks will not be filtered\n    in any way. To detect only significant peaks, filter the peaks by using\n    the prominence as a threshold.</p>\n\n<pre><code>Args:\n\n    image: Complete SLI measurement image stack as a 2D/3D Numpy array\n\nReturns:\n\n2D/3D boolean image containing masking the peaks with `True`\n</code></pre>\n", "parameters": ["image"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.num_peaks", "modulename": "SLIX._CPU.toolbox", "qualname": "num_peaks", "type": "function", "doc": "<p>Calculate the number of peaks from each line profile in an SLI image series\n    by detecting all peaks and applying thresholds to remove unwanted peaks.</p>\n\n<pre><code>Args:\n\n    image: Full SLI measurement (series of images) which is prepared for the\n           pipeline using the SLIX toolbox methods.\n\n    peak_image: Boolean NumPy array specifying the peak positions in the full SLI stack\n\nReturns:\n\n    Array where each entry corresponds to the number of detected peaks within\n    the first dimension of the SLI image series.\n</code></pre>\n", "parameters": ["image", "peak_image"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.normalize", "modulename": "SLIX._CPU.toolbox", "qualname": "normalize", "type": "function", "doc": "<p>Normalize given line profile by using a normalization technique based on\nthe kind_of_normalization parameter.</p>\n\n<p>0 : Scale line profile to be between 0 and 1</p>\n\n<p>1 : Divide line profile through its mean value</p>\n\n<p>Arguments:\n    image: Full SLI measurement (series of images) which is\n           prepared for the pipeline using the SLIX toolbox methods.\n    kind_of_normalization: Normalization technique which will be used for\n    the calculation</p>\n\n<p>Returns:\n    numpy.array -- Image where each pixel is normalized by the last axis\n    of the image</p>\n", "parameters": ["image", "kind_of_normalization"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.peak_prominence", "modulename": "SLIX._CPU.toolbox", "qualname": "peak_prominence", "type": "function", "doc": "<p>Calculate the peak prominence of all given peak positions within a line\nprofile. The line profile will be normalized by dividing the line profile\nthrough its mean value. Therefore, values above 1 are possible.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\nfurther analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\nkind_of_normalization: Normalize given line profile by using a\nnormalization technique based on the kind_of_normalization parameter.\n   0 : Scale line profile to be between 0 and 1\n   1 : Divide line profile through its mean value\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Floating point value containing the mean peak prominence of the line\nprofile in degrees. the mean peak prominence of the line\n</code></pre>\n\n<p>profile in degrees.</p>\n", "parameters": ["image", "peak_image", "kind_of_normalization"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.mean_peak_prominence", "modulename": "SLIX._CPU.toolbox", "qualname": "mean_peak_prominence", "type": "function", "doc": "<p>Calculate the mean peak prominence of all given peak positions within a\nline profile. The line profile will be normalized by dividing the line\nprofile through its mean value. Therefore, values above 1 are possible.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\n    further analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\nkind_of_normalization: Normalize given line profile by using a\nnormalization technique based on the kind_of_normalization parameter.\n   0 : Scale line profile to be between 0 and 1\n   1 : Divide line profile through its mean value\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Floating point value containing the mean peak prominence of the line\nprofile in degrees.\n</code></pre>\n", "parameters": ["image", "peak_image", "kind_of_normalization"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.peak_width", "modulename": "SLIX._CPU.toolbox", "qualname": "peak_width", "type": "function", "doc": "<p>Calculate the peak width of all given peak positions within a line profile.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\nfurther analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ntarget_height: Relative peak height in relation to the prominence of the\ngiven peak.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array where each entry corresponds to the peak width of the line\nprofile. The values are in degree.\n</code></pre>\n", "parameters": ["image", "peak_image", "target_height"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.mean_peak_width", "modulename": "SLIX._CPU.toolbox", "qualname": "mean_peak_width", "type": "function", "doc": "<p>Calculate the mean peak width of all given peak positions within a line\nprofile.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\nfurther analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ntarget_height: Relative peak height in relation to the prominence of the\ngiven peak.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array where each entry corresponds to the mean peak width of the\nline profile. The values are in degree.\n</code></pre>\n", "parameters": ["image", "peak_image", "target_height"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.peak_distance", "modulename": "SLIX._CPU.toolbox", "qualname": "peak_distance", "type": "function", "doc": "<p>Calculate the mean peak distance in degrees between two corresponding peaks\nfor each line profile in an SLI image series.</p>\n\n<p>Args:</p>\n\n<pre><code>peak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ncentroids: Use centroid calculation to better determine the peak position\nregardless of the number of\nmeasurements / illumination angles used.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array of floating point values containing the peak distance of the\nline profiles in degrees in their respective peak position. The first peak\nof each peak pair will show the distance between peak_1 and peak_2 while\nthe second peak will show 360 - (peak_2 - peak_1).\n</code></pre>\n", "parameters": ["peak_image", "centroids"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.mean_peak_distance", "modulename": "SLIX._CPU.toolbox", "qualname": "mean_peak_distance", "type": "function", "doc": "<p>Calculate the mean peak distance in degrees between two corresponding peaks\nfor each line profile in an SLI image series.</p>\n\n<p>Args:</p>\n\n<pre><code>peak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ncentroids: Use centroid calculation to better determine the peak position\nregardless of the number of\nmeasurements / illumination angles used.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array of floating point values containing the mean peak distance of\nthe line profiles in degrees.\n</code></pre>\n", "parameters": ["peak_image", "centroids"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.direction", "modulename": "SLIX._CPU.toolbox", "qualname": "direction", "type": "function", "doc": "<p>Calculate up to <code>number_of_directions</code> direction angles based on the given\npeak positions. If more than <code>number_of_directions*2</code> peaks are present, no\ndirection angle will be calculated to avoid errors. This will result in a\ndirection angle of BACKGROUND_COLOR. The peak positions are determined by\nthe position of the corresponding peak pairs (i.e. 6 peaks: 1+4, 2+5, 3+6).\nIf two peaks are too far away or too near (outside of 180\u00b0\u00b135\u00b0), the\ndirection angle will be considered as invalid, resulting in a direction\nangle of BACKGROUND_COLOR.</p>\n\n<p>Args:</p>\n\n<pre><code>correction_angle: Correct the resulting direction angle by the value.\nThis is useful when the stack or camera was rotated.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ncentroids: Centroids resulting from `centroid_correction` for more accurate\n           results\n\nnumber_of_directions: Number of directions which shall be generated.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array with the shape (x, y, `number_of_directions`) containing up to\n`number_of_directions` direction angles. x equals the number of pixels of\nthe SLI image series. If a direction angle is invalid or missing, the\narray entry will be BACKGROUND_COLOR instead.\n</code></pre>\n", "parameters": ["peak_image", "centroids", "correction_angle", "number_of_directions"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.centroid_correction", "modulename": "SLIX._CPU.toolbox", "qualname": "centroid_correction", "type": "function", "doc": "<p>Correct peak positions from a line profile by looking at only the peak\nwith a given threshold using a centroid calculation. If a minimum is found\nin the considered interval, this minimum will be used as the limit instead.\nThe range for the peak correction is limited by\nMAX_DISTANCE_FOR_CENTROID_ESTIMATION.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\nfurther analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\nlow_prominence: Lower prominence bound for detecting a peak.\n\nhigh_prominence: Higher prominence bound for detecting a peak.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array with the positions of all detected peak positions corrected\nwith the centroid calculation.\n</code></pre>\n", "parameters": ["image", "peak_image", "low_prominence", "high_prominence"], "funcdef": "def"}, {"fullname": "SLIX._CPU.toolbox.unit_vectors", "modulename": "SLIX._CPU.toolbox", "qualname": "unit_vectors", "type": "function", "doc": "<p>Calculate the unit vectors (UnitX, UnitY) from a given direction angle.</p>\n\n<p>Args:</p>\n\n<pre><code>direction: 3D NumPy array - direction angles in degrees\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>UnitX, UnitY: 3D NumPy array, 3D NumPy array\n    x- and y-vector component in arrays\n</code></pre>\n", "parameters": ["direction"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox", "modulename": "SLIX._GPU.toolbox", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "SLIX._GPU.toolbox.background_mask", "modulename": "SLIX._GPU.toolbox", "qualname": "background_mask", "type": "function", "doc": "<p>Creates a background mask by setting all image pixels with low scattering\nsignals to zero. As all background pixels are near zero for all images in\nthe SLI image stack, this method should remove most of the background\nallowing for better approximations using the available features.\nIt is advised to use this function.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Complete SLI measurement image stack as a 2D/3D Numpy array\n\nthreshold: Threshhold for mask creation (default: 10)\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\n              Numpy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>numpy.array: 1D/2D-image which masks the background as True and\n             foreground as False\n</code></pre>\n", "parameters": ["image", "threshold", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.peaks", "modulename": "SLIX._GPU.toolbox", "qualname": "peaks", "type": "function", "doc": "<p>Detect all peaks from a full SLI measurement. Peaks will not be filtered\nin any way. To detect only significant peaks, filter the peaks by using\nthe prominence as a threshold.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Complete SLI measurement image stack as a 2D/3D Numpy array\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\n              Numpy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<p>2D/3D boolean image containing masking the peaks with <code>True</code></p>\n", "parameters": ["image", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.num_peaks", "modulename": "SLIX._GPU.toolbox", "qualname": "num_peaks", "type": "function", "doc": "<p>Calculate the number of peaks from each line profile in an SLI image series\nby detecting all peaks and applying thresholds to remove unwanted peaks.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Full SLI measurement (series of images) which is prepared for the\n       pipeline using the SLIX toolbox methods.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full SLI stack\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or Numpy\n              array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Array where each entry corresponds to the number of detected peaks within\nthe first dimension of the SLI image series.\n</code></pre>\n", "parameters": ["image", "peak_image", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.normalize", "modulename": "SLIX._GPU.toolbox", "qualname": "normalize", "type": "function", "doc": "<p>Normalize given line profile by using a normalization technique based on\nthe kind_of_normalization parameter.</p>\n\n<p>0 : Scale line profile to be between 0 and 1</p>\n\n<p>1 : Divide line profile through its mean value</p>\n\n<p>Arguments:\n    image: Full SLI measurement (series of images) which is\n           prepared for the pipeline using the SLIX toolbox methods.\n    kind_of_normalization: Normalization technique which will be used for\n    the calculation\n    return_numpy:  Specifies if a CuPy or Numpy array will be returned.</p>\n\n<p>Returns:\n    numpy.array -- Image where each pixel is normalized by the last axis\n    of the image</p>\n", "parameters": ["image", "kind_of_normalization", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.peak_prominence", "modulename": "SLIX._GPU.toolbox", "qualname": "peak_prominence", "type": "function", "doc": "<p>Calculate the peak prominence of all given peak positions within a line\nprofile. The line profile will be normalized by dividing the line profile\nthrough its mean value. Therefore, values above 1 are possible.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\nfurther analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\nkind_of_normalization: Normalize given line profile by using a\nnormalization technique based on the kind_of_normalization parameter.\n   0 : Scale line profile to be between 0 and 1\n   1 : Divide line profile through its mean value\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or Numpy\narray will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Floating point value containing the mean peak prominence of the line\nprofile in degrees.\n</code></pre>\n", "parameters": ["image", "peak_image", "kind_of_normalization", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.mean_peak_prominence", "modulename": "SLIX._GPU.toolbox", "qualname": "mean_peak_prominence", "type": "function", "doc": "<p>Calculate the mean peak prominence of all given peak positions within a\nline profile. The line profile will be normalized by dividing the line\nprofile through its mean value. Therefore, values above 1 are possible.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\n    further analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\nkind_of_normalization: Normalize given line profile by using a\nnormalization technique based on the kind_of_normalization parameter.\n   0 : Scale line profile to be between 0 and 1\n   1 : Divide line profile through its mean value\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or Numpy\narray will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Floating point value containing the mean peak prominence of the line\nprofile in degrees.\n</code></pre>\n", "parameters": ["image", "peak_image", "kind_of_normalization", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.peak_width", "modulename": "SLIX._GPU.toolbox", "qualname": "peak_width", "type": "function", "doc": "<p>Calculate the peak width of all given peak positions within a line profile.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\nfurther analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ntarget_height: Relative peak height in relation to the prominence of the\ngiven peak.\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or Numpy\narray will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array where each entry corresponds to the peak width of the line\nprofile. The values are in degree.\n</code></pre>\n", "parameters": ["image", "peak_image", "target_height", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.mean_peak_width", "modulename": "SLIX._GPU.toolbox", "qualname": "mean_peak_width", "type": "function", "doc": "<p>Calculate the mean peak width of all given peak positions within a line\nprofile.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\nfurther analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ntarget_height: Relative peak height in relation to the prominence of the\ngiven peak.\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or Numpy\narray will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array where each entry corresponds to the mean peak width of the\nline profile. The values are in degree.\n</code></pre>\n", "parameters": ["image", "peak_image", "target_height", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.peak_distance", "modulename": "SLIX._GPU.toolbox", "qualname": "peak_distance", "type": "function", "doc": "<p>Calculate the mean peak distance in degrees between two corresponding peaks\nfor each line profile in an SLI image series.</p>\n\n<p>Args:</p>\n\n<pre><code>peak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ncentroids: Use centroid calculation to better determine the peak position\nregardless of the number of\nmeasurements / illumination angles used.\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or Numpy\narray will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array of floating point values containing the peak distance of the\nline profiles in degrees in their respective peak position. The first peak\nof each peak pair will show the distance between peak_1 and peak_2 while\nthe second peak will show 360 - (peak_2 - peak_1).\n</code></pre>\n", "parameters": ["peak_image", "centroids", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.mean_peak_distance", "modulename": "SLIX._GPU.toolbox", "qualname": "mean_peak_distance", "type": "function", "doc": "<p>Calculate the mean peak distance in degrees between two corresponding peaks\nfor each line profile in an SLI image series.</p>\n\n<p>Args:</p>\n\n<pre><code>peak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ncentroids: Use centroid calculation to better determine the peak position\nregardless of the number of\nmeasurements / illumination angles used.\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or Numpy\narray will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array of floating point values containing the mean peak distance of\nthe line profiles in degrees.\n</code></pre>\n", "parameters": ["peak_image", "centroids", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.direction", "modulename": "SLIX._GPU.toolbox", "qualname": "direction", "type": "function", "doc": "<p>Calculate up to <code>number_of_directions</code> direction angles based on the given\npeak positions. If more than <code>number_of_directions*2</code> peaks are present, no\ndirection angle will be calculated to avoid errors. This will result in a\ndirection angle of BACKGROUND_COLOR. The peak positions are determined by\nthe position of the corresponding peak pairs (i.e. 6 peaks: 1+4, 2+5, 3+6).\nIf two peaks are too far away or too near (outside of 180\u00b0\u00b135\u00b0), the\ndirection angle will be considered as invalid, resulting in a direction\nangle of BACKGROUND_COLOR.</p>\n\n<p>Args:</p>\n\n<pre><code>correction_angle: Correct the resulting direction angle by the value.\nThis is useful when the stack or camera was rotated.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ncentroids: Centroids resulting from `centroid_correction` for more accurate\n           results\n\nnumber_of_directions: Number of directions which shall be generated.\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or Numpy\narray will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array with the shape (x, y, `number_of_directions`) containing up to\n`number_of_directions` direction angles. x equals the number of pixels of\nthe SLI image series. If a direction angle is invalid or missing, the\narray entry will be BACKGROUND_COLOR instead.\n</code></pre>\n", "parameters": ["peak_image", "centroids", "correction_angle", "number_of_directions", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.centroid_correction", "modulename": "SLIX._GPU.toolbox", "qualname": "centroid_correction", "type": "function", "doc": "<p>Correct peak positions from a line profile by looking at only the peak\nwith a given threshold using a centroid calculation. If a minimum is found\nin the considered interval, this minimum will be used as the limit instead.\nThe range for the peak correction is limited by\nMAX_DISTANCE_FOR_CENTROID_ESTIMATION.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\nfurther analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\nlow_prominence: Lower prominence bound for detecting a peak.\n\nhigh_prominence: Higher prominence bound for detecting a peak.\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or Numpy\narray will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array with the positions of all detected peak positions corrected\nwith the centroid calculation.\n</code></pre>\n", "parameters": ["image", "peak_image", "low_prominence", "high_prominence", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX._GPU.toolbox.unit_vectors", "modulename": "SLIX._GPU.toolbox", "qualname": "unit_vectors", "type": "function", "doc": "<p>Calculate the unit vectors (UnitX, UnitY) from a given direction angle.</p>\n\n<p>Args:</p>\n\n<pre><code>direction: 3D NumPy array - direction angles in degrees\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or Numpy\narray will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>UnitX, UnitY: 3D NumPy array, 3D NumPy array\n    x- and y-vector component in arrays\n</code></pre>\n", "parameters": ["direction", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager", "modulename": "SLIX.attributemanager", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "SLIX.attributemanager.AttributeHandler", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler", "type": "class", "doc": "<p></p>\n"}, {"fullname": "SLIX.attributemanager.AttributeHandler.__init__", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.__init__", "type": "function", "doc": "<p>Initialize the AttributeHandler with a already opened HDF5 dataset.\nThis dataset will be used for all operations of this class.</p>\n\n<p>Args:</p>\n\n<pre><code>dataset: h5py dataset\n</code></pre>\n", "parameters": ["self", "dataset"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager.AttributeHandler.dataset", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.dataset", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "SLIX.attributemanager.AttributeHandler.attrs", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.attrs", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "SLIX.attributemanager.AttributeHandler.does_attribute_exist", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.does_attribute_exist", "type": "function", "doc": "<p>Check if the attribute already exists in the HDF5 dataset.\nThis has to be done before doing any operations because\nwriting to an HDF5 attribute without properly deleting it first\ncan result in errors.</p>\n\n<p>Args:</p>\n\n<pre><code>attribute_name: Name of the attribute you want to check\n                in the dataset.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "attribute_name"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager.AttributeHandler.delete_attribute", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.delete_attribute", "type": "function", "doc": "<p>Delete an attribute from a HDF5 dataset.</p>\n\n<p>Args:</p>\n\n<pre><code>attribute_name: Name of the attribute you want to delete in the\n                dataset.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "attribute_name"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager.AttributeHandler.get_attribute", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.get_attribute", "type": "function", "doc": "<p>Get an attribute from the HDF5 dataset.</p>\n\n<p>Args:</p>\n\n<pre><code>attribute_name: Name of the attribute you want to get from the\n                dataset.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Value from the dataset (string, float, int, bool\nor numpy.array) if the attribute es present. Otherwise None\nwill be returned.\n</code></pre>\n", "parameters": ["self", "attribute_name"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager.AttributeHandler.set_attribute", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.set_attribute", "type": "function", "doc": "<p>Set an attribute in the HDF5 dataset.</p>\n\n<p>Args:</p>\n\n<pre><code>attribute_name: Name of the attribute you want to get from the\n                dataset.\n\nvalue: String, Float, Integer, Boolean or numpy array you\n       want to set in the HDF5 attribute.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "attribute_name", "value"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager.AttributeHandler.set_reference_modality_to", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.set_reference_modality_to", "type": "function", "doc": "<p>When SLIX generates an image based on a SLI measurement, the original\nHDF5 file can be saves as a reference for the future.\nThis method adds the reference file and dataset to the output.\nHowever, the input HDF5 and dataset must contain an id attribute.</p>\n\n<p>Args:</p>\n\n<pre><code>references: Reference list of AttributeHandlers\n            containing the dataset of the input file.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "references"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager.AttributeHandler.add_creator", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.add_creator", "type": "function", "doc": "<p>Adds the creator of the HDF5 file to the dataset.\nReturns: None</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager.AttributeHandler.add_id", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.add_id", "type": "function", "doc": "<p>Computes a unique ID that will be added to the dataset of the HDF5\nfile. The ID is a sha256 hash containing some of the attributes\nas well as a 50 digit randomized prefix.\nReturns: None</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager.AttributeHandler.copy_all_attributes_to", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.copy_all_attributes_to", "type": "function", "doc": "<p>Copies all attributes from one AttributeHandler to another.\nExceptions can be given in a list. In general, the following attributes\nwill not be copied: \"created_by\", \"creation_time\", \"id\",\n\"image_modality\", \"reference_images\", \"software\", \"software_revision\",\n\"software_parameters\", \"filename\", \"path\", \"scale\"</p>\n\n<p>Args:</p>\n\n<pre><code>dest: Destination where the attributes of this handler should be\n      copied to.\n\nexceptions: Exceptions in form of a list with strings.\n            Those attributes will not be copied when calling the\n            method.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "dest", "exceptions"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager.AttributeHandler.copy_attributes_to", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.copy_attributes_to", "type": "function", "doc": "<p>Copies given attributes from one AttributeHandler to another.</p>\n\n<p>Args:</p>\n\n<pre><code>dest: Destination where the attributes of this handler should be\n      copied to.\n\nattributes: Attributes as a list of strings which will be copied.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "dest", "attributes"], "funcdef": "def"}, {"fullname": "SLIX.attributemanager.AttributeHandler.copy_attribute_to", "modulename": "SLIX.attributemanager", "qualname": "AttributeHandler.copy_attribute_to", "type": "function", "doc": "<p>Copy a single attribute from one AttributeHandler to another.</p>\n\n<p>Args:</p>\n\n<pre><code>dest: Destination where the attributes of this handler should be\n      copied to.\n\nattribute_name: Attribute name which will be copied.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "dest", "attribute_name"], "funcdef": "def"}, {"fullname": "SLIX.io", "modulename": "SLIX.io", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "SLIX.io.H5FileReader", "modulename": "SLIX.io", "qualname": "H5FileReader", "type": "class", "doc": "<p>This class allows to read HDF5 files from your file system.\nIt supports reading datasets but not reading attributes.</p>\n"}, {"fullname": "SLIX.io.H5FileReader.__init__", "modulename": "SLIX.io", "qualname": "H5FileReader.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "SLIX.io.H5FileReader.open", "modulename": "SLIX.io", "qualname": "H5FileReader.open", "type": "function", "doc": "<p>Args:</p>\n\n<pre><code>path: Path on the filesystem to the HDF5 file which will be read\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "path"], "funcdef": "def"}, {"fullname": "SLIX.io.H5FileReader.close", "modulename": "SLIX.io", "qualname": "H5FileReader.close", "type": "function", "doc": "<p>Close the currently opened file, if any is open.</p>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "SLIX.io.H5FileReader.read", "modulename": "SLIX.io", "qualname": "H5FileReader.read", "type": "function", "doc": "<p>Read a dataset from the currently opened file, if any is open.\nThe content of the dataset will be stored for future use.</p>\n\n<p>Args:</p>\n\n<pre><code>dataset: Path to the dataset within the HDF5\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>The opened dataset.\n</code></pre>\n", "parameters": ["self", "dataset"], "funcdef": "def"}, {"fullname": "SLIX.io.H5FileWriter", "modulename": "SLIX.io", "qualname": "H5FileWriter", "type": "class", "doc": "<p>This class allows to write HDF5 files to your file system.\nIt supports writing datasets and writing attributes.</p>\n"}, {"fullname": "SLIX.io.H5FileWriter.__init__", "modulename": "SLIX.io", "qualname": "H5FileWriter.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "SLIX.io.H5FileWriter.add_symlink", "modulename": "SLIX.io", "qualname": "H5FileWriter.add_symlink", "type": "function", "doc": "<p>Adds a symbolic link from one dataset to another path.</p>\n\n<p>Args:</p>\n\n<pre><code>dataset: Dataset path within the HDF5\n\nsymlink_path: Path to the symlink.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "dataset", "symlink_path"], "funcdef": "def"}, {"fullname": "SLIX.io.H5FileWriter.add_plim_attributes", "modulename": "SLIX.io", "qualname": "H5FileWriter.add_plim_attributes", "type": "function", "doc": "<p>PLIM is a package used in the 3D-PLI group to read and write multiple\nattributes from/to a HDF5 file. The basic functionality is added in\nattributemanager.py. Calling this method will write many attributes to\nthe HDF5 file at the given dataset.</p>\n\n<p>This includes: A unique ID, the creator, software parameters,\n               creation time, software_revision, image_modality and\n               all attributes from the original stack, if it was a\n               HDF5</p>\n\n<p>Args:\n    stack_path: Path of the stack that was used to calculate the\n                content which will be written to the HDF5 file.\n    dataset: Dataset where the attributes shall be written to.</p>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "stack_path", "dataset"], "funcdef": "def"}, {"fullname": "SLIX.io.H5FileWriter.write_attribute", "modulename": "SLIX.io", "qualname": "H5FileWriter.write_attribute", "type": "function", "doc": "<p>Write a single attribute to a dataset.</p>\n\n<p>Args:</p>\n\n<pre><code>dataset: Path to the dataset within the HDF5\n\nattr_name: Name of the attribute which shall be written.\n\nvalue: Value of the attribute that shall be written.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "dataset", "attr_name", "value"], "funcdef": "def"}, {"fullname": "SLIX.io.H5FileWriter.write_dataset", "modulename": "SLIX.io", "qualname": "H5FileWriter.write_dataset", "type": "function", "doc": "<p>Write a dataset to the currently opened HDF5 file, if any is open.\nIf no HDF5 file is open, this method will return without writing.</p>\n\n<p>Args:</p>\n\n<pre><code>dataset: Path to the dataset within the HDF5 file.\n\ncontent: Content which shall be written.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "dataset", "content"], "funcdef": "def"}, {"fullname": "SLIX.io.H5FileWriter.close", "modulename": "SLIX.io", "qualname": "H5FileWriter.close", "type": "function", "doc": "<p>Close the currently opened file.</p>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "SLIX.io.H5FileWriter.open", "modulename": "SLIX.io", "qualname": "H5FileWriter.open", "type": "function", "doc": "<p>Open a new HDF5 file with the given path. If another file was opened,\nit will be closed first.</p>\n\n<p>Args:</p>\n\n<pre><code>path: Path to the HDF5 file.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["self", "path"], "funcdef": "def"}, {"fullname": "SLIX.io.read_folder", "modulename": "SLIX.io", "qualname": "read_folder", "type": "function", "doc": "<p>Reads multiple image files from a folder and returns the resulting stack.\nTo find the images in the right order, a regex is used which will search\nfor files with the following pattern:\n[prefix]_p[Nr][suffix]. The start number doesn't need to be 0.\nThe files are sorted with a natural sort, meaning that files like\n0002, 1, 004, 3 will be sorted as 1, 0002, 3, 004.</p>\n\n<p>The follwing regex is used to find the measurements:\n<code>.*_+p[0-9]+_?.*\\.(tif{1,2}|jpe*g|nii|h5|png)</code></p>\n\n<p>Supported file formats for the image file equal the supported formats of\nSLIX.imread.</p>\n\n<p>Args:</p>\n\n<pre><code>filepath: Path to folder\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>numpy.array: Image with shape [x, y, z] where [x, y] is the size\nof a single image and z specifies the number of measurements\n</code></pre>\n", "parameters": ["filepath"], "funcdef": "def"}, {"fullname": "SLIX.io.imread", "modulename": "SLIX.io", "qualname": "imread", "type": "function", "doc": "<p>Reads image file and returns it.\nSupported file formats: HDF5, NIfTI, Tiff.</p>\n\n<p>Args:</p>\n\n<pre><code>filepath: Path to image\n\ndataset: When reading a HDF5 file, a dataset is required.\n         Default: '/Image'\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>numpy.array: Image with shape [x, y, z] where [x, y] is the size\nof a single image and z specifies the number of measurements\n</code></pre>\n", "parameters": ["filepath", "dataset"], "funcdef": "def"}, {"fullname": "SLIX.io.imwrite", "modulename": "SLIX.io", "qualname": "imwrite", "type": "function", "doc": "<p>Write generated image to given filepath.\nSupported file formats: HDF5, NIfTI, Tiff.\nOther file formats are only indirectly supported and might result in\nerrors.</p>\n\n<p>Args:</p>\n\n<pre><code>filepath: Path to image\n\ndata: Data which will be written to the disk\n\ndataset: When writing a HDF5 file, a dataset is required.\n         Default: '/Image'\n\noriginal_stack_path: Path to the original image stack used to create\n                     this content. Only required when a HDF5 file\n                     is written.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["filepath", "data", "dataset", "original_stack_path"], "funcdef": "def"}, {"fullname": "SLIX.io.imwrite_rgb", "modulename": "SLIX.io", "qualname": "imwrite_rgb", "type": "function", "doc": "<p>Write generated RGB image to given filepath.\nSupported file formats: HDF5, Tiff.\nOther file formats are only indirectly supported and might result in\nerrors.</p>\n\n<p>Args:</p>\n\n<pre><code>filepath: Path to image\n\ndata: Data which will be written to the disk\n\ndataset: When reading a HDF5 file, a dataset is required.\n         Default: '/Image'\n\noriginal_stack_path: Path to the original image stack used to\n                     create this content. Only required when a\n                     HDF5 file is written.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>None\n</code></pre>\n", "parameters": ["filepath", "data", "dataset", "original_stack_path"], "funcdef": "def"}, {"fullname": "SLIX.preparation", "modulename": "SLIX.preparation", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "SLIX.preparation.low_pass_fourier_smoothing", "modulename": "SLIX.preparation", "qualname": "low_pass_fourier_smoothing", "type": "function", "doc": "<p></p>\n", "parameters": ["image", "threshold_low", "threshold_high"], "funcdef": "def"}, {"fullname": "SLIX.preparation.savitzky_golay_smoothing", "modulename": "SLIX.preparation", "qualname": "savitzky_golay_smoothing", "type": "function", "doc": "<p>Applies Savitzky-Golay filter to given roiset and returns the\nsmoothened measurement.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Complete SLI measurement image stack as a 2D/3D Numpy array\n\nwindow_length: Used window length for the Savitzky-Golay filter\n\npolyorder: Used polynomial order for the Savitzky-Golay filter\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Complete SLI measurement image with applied Savitzky-Golay filter\nand the same shape as the original image.\n</code></pre>\n", "parameters": ["image", "window_length", "polyorder"], "funcdef": "def"}, {"fullname": "SLIX.preparation.thin_out", "modulename": "SLIX.preparation", "qualname": "thin_out", "type": "function", "doc": "<p>Thin out the image stack used for SLIX. This can be useful when the image\nstack is quite large and should be processed quickly. This can also prove\nuseful if there is a lot of noise that could be filtered by using a lower\nresolution image.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Image that should be thinned out.\n\nfactor: Factor which will be used for thinning the image. A factor\n        of N means that every N-th pixel will be kept.\n\nstrategy: Strategy used for thinning out the image. Available methods:\n          'plain' (keep the pixel),\n          'average' (calculate average of area),\n          'median' (calculate the median of area)\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>numpy.ndarray with the thinned out image\n</code></pre>\n", "parameters": ["image", "factor", "strategy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox", "modulename": "SLIX.toolbox", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "SLIX.toolbox.background_mask", "modulename": "SLIX.toolbox", "qualname": "background_mask", "type": "function", "doc": "<p>Creates a background mask by setting all image pixels with low scattering\nsignals to zero. As all background pixels are near zero for all images in\nthe SLI image stack, this method should remove most of the background\nallowing for better approximations using the available features.\nIt is advised to use this function.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Complete SLI measurement image stack as a 2D/3D NumPy array\n\nthreshold: Threshhold for mask creation (default: 10)\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\n              NumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>numpy.array: 1D/2D-image which masks the background as True and\n             foreground as False\n</code></pre>\n", "parameters": ["image", "threshold", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.peaks", "modulename": "SLIX.toolbox", "qualname": "peaks", "type": "function", "doc": "<p>Detect all peaks from a full SLI measurement. Peaks will not be filtered\nin any way. To detect only significant peaks, filter the peaks by using\nthe prominence as a threshold.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Complete SLI measurement image stack as a 2D/3D NumPy array\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\n              NumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<p>2D/3D boolean image containing masking the peaks with <code>True</code></p>\n", "parameters": ["image", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.significant_peaks", "modulename": "SLIX.toolbox", "qualname": "significant_peaks", "type": "function", "doc": "<p>Detect all peaks from a full SLI measurement and filter them by passing\nthresholds.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Complete SLI measurement image stack as a 2D/3D NumPy array\n\nlow_prominence: Minimum prominence needed by peak to count as a peak.\n                Peaks below this threshold will not be considered as a\n                peak.\n\nhigh_prominence: Maximum prominence needed by peak to count as a peak.\n                 Peaks below this threshold will not be considered as a\n                 peak.\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\n              NumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>2D/3D boolean image containing masking the peaks with `True`\n</code></pre>\n", "parameters": ["image", "low_prominence", "high_prominence", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.num_peaks", "modulename": "SLIX.toolbox", "qualname": "num_peaks", "type": "function", "doc": "<p>Calculate the number of peaks from each line profile in an SLI image series\nby detecting all peaks and applying thresholds to remove unwanted peaks.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Full SLI measurement (series of images) which is prepared for\n       the pipeline using the SLIX toolbox methods.\n\nlow_prominence: Lower prominence bound for detecting a peak.\n\nhigh_prominence: Higher prominence bound for detecting a peak.\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_NumPy: Necessary if using `use_gpu`. Specifies if a CuPy or\n              NumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Array where each entry corresponds to the number of detected peaks within\nthe first dimension of the SLI image series.\n</code></pre>\n", "parameters": ["image", "low_prominence", "high_prominence", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.direction", "modulename": "SLIX.toolbox", "qualname": "direction", "type": "function", "doc": "<p>Calculate up to <code>number_of_directions</code> direction angles based on the given\npeak positions. If more than <code>number_of_directions*2</code> peaks are present, no\ndirection angle will be calculated to avoid errors. This will result in a\ndirection angle of BACKGROUND_COLOR. The peak positions are determined by\nthe position of the corresponding peak pairs (i.e. 6 peaks: 1+4, 2+5, 3+6).\nIf two peaks are too far away or too near (outside of 180\u00b0\u00b135\u00b0), the\ndirection angle will be considered as invalid, resulting in a direction\nangle of BACKGROUND_COLOR.</p>\n\n<p>Args:</p>\n\n<pre><code>correction_angle: Correct the resulting direction angle by the value.\nThis is useful when the stack or camera was rotated.\n\npeak_image: Boolean NumPy array specifying the peak positions in the\n            full SLI stack\n\ncentroids: Centroids resulting from `centroid_correction` for more accurate\n           results\n\nnumber_of_directions: Number of directions which shall be generated.\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\n              NumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array with the shape (x, y, `number_of_directions`) containing\nup to `number_of_directions` direction angles. x equals the number\nof pixels of the SLI image series. If a direction angle is invalid\nor missing, the array entry will be BACKGROUND_COLOR instead.\n</code></pre>\n", "parameters": ["peak_image", "centroids", "correction_angle", "number_of_directions", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.peak_distance", "modulename": "SLIX.toolbox", "qualname": "peak_distance", "type": "function", "doc": "<p>Calculate the mean peak distance in degrees between two corresponding peaks\nfor each line profile in an SLI image series.</p>\n\n<p>Args:</p>\n\n<pre><code>peak_image: Boolean NumPy array specifying the peak positions in the\n            full SLI stack\n\ncentroids: Use centroid calculation to better determine the peak\nposition regardless of the number of measurements / illumination\nangles used.\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\n              NumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array of floating point values containing the peak distance of\nthe line profiles in degrees in their respective peak position. The\nfirst peak of each peak pair will show the distance between peak_1\nand peak_2 while the second peak will show 360 - (peak_2 - peak_1).\n</code></pre>\n", "parameters": ["peak_image", "centroids", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.mean_peak_distance", "modulename": "SLIX.toolbox", "qualname": "mean_peak_distance", "type": "function", "doc": "<p>Calculate the mean peak distance in degrees between two corresponding peaks\nfor each line profile in an SLI image series.</p>\n\n<p>Args:</p>\n\n<pre><code>peak_image: Boolean NumPy array specifying the peak positions in the\n            full SLI stack\n\ncentroids: Use centroid calculation to better determine the peak position\nregardless of the number of measurements / illumination angles used.\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\n              NumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array of floating point values containing the mean peak distance\nof the line profiles in degrees.\n</code></pre>\n", "parameters": ["peak_image", "centroids", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.peak_prominence", "modulename": "SLIX.toolbox", "qualname": "peak_prominence", "type": "function", "doc": "<p>Calculate the peak prominence of all given peak positions within a line\nprofile. The line profile will be normalized by dividing the line profile\nthrough its mean value. Therefore, values above 1 are possible.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will be\nfurther analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the\n            full SLI stack\n\nkind_of_normalization: Normalize given line profile by using a\nnormalization technique based on the kind_of_normalization parameter.\n   0 : Scale line profile to be between 0 and 1\n   1 : Divide line profile through its mean value\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\n              NumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Floating point value containing the mean peak prominence of the line\nprofile in degrees.\n</code></pre>\n", "parameters": ["image", "peak_image", "kind_of_normalization", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.mean_peak_prominence", "modulename": "SLIX.toolbox", "qualname": "mean_peak_prominence", "type": "function", "doc": "<p>Calculate the mean peak prominence of all given peak positions within a\nline profile. The line profile will be normalized by dividing the line\nprofile through its mean value. Therefore, values above 1 are possible.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array\n       will be further analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the\n            full SLI stack\n\nkind_of_normalization: Normalize given line profile by using a\nnormalization technique based on the kind_of_normalization parameter.\n   0 : Scale line profile to be between 0 and 1\n   1 : Divide line profile through its mean value\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\nNumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>Floating point value containing the mean peak prominence of the line\nprofile in degrees.\n</code></pre>\n", "parameters": ["image", "peak_image", "kind_of_normalization", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.peak_width", "modulename": "SLIX.toolbox", "qualname": "peak_width", "type": "function", "doc": "<p>Calculate the peak width of all given peak positions within a line profile.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will\nbe further analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the full\nSLI stack\n\ntarget_height: Relative peak height in relation to the prominence of the\ngiven peak.\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\nNumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array where each entry corresponds to the peak width of the line\nprofile. The values are in degree.\n</code></pre>\n", "parameters": ["image", "peak_image", "target_height", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.mean_peak_width", "modulename": "SLIX.toolbox", "qualname": "mean_peak_width", "type": "function", "doc": "<p>Calculate the mean peak width of all given peak positions within a line\nprofile.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will\nbe further analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the\nfull SLI stack\n\ntarget_height: Relative peak height in relation to the prominence of\nthe given peak.\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\nNumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>NumPy array where each entry corresponds to the mean peak width of the\nline profile. The values are in degree.\n</code></pre>\n", "parameters": ["image", "peak_image", "target_height", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.centroid_correction", "modulename": "SLIX.toolbox", "qualname": "centroid_correction", "type": "function", "doc": "<p>Correct peak positions from a line profile by looking at only the peak\nwith a given threshold using a centroid calculation. If a minimum is found\nin the considered interval, this minimum will be used as the limit instead.\nThe range for the peak correction is limited by\nMAX_DISTANCE_FOR_CENTROID_ESTIMATION.</p>\n\n<p>Args:</p>\n\n<pre><code>image: Original line profile used to detect all peaks. This array will\nbe further analyzed to better determine the peak positions.\n\npeak_image: Boolean NumPy array specifying the peak positions in the\nfull SLI stack\n\nlow_prominence: Lower prominence bound for detecting a peak.\n\nhigh_prominence: Higher prominence bound for detecting a peak.\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\nNumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>_numpy array with the positions of all detected peak positions corrected\nwith the centroid calculation.\n</code></pre>\n", "parameters": ["image", "peak_image", "low_prominence", "high_prominence", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.toolbox.unit_vectors", "modulename": "SLIX.toolbox", "qualname": "unit_vectors", "type": "function", "doc": "<p>Calculate the unit vectors (UnitX, UnitY) from a given direction angle.</p>\n\n<p>Args:</p>\n\n<pre><code>direction: 3D NumPy array - direction angles in degrees\n\nuse_gpu: If available use the GPU for calculation\n\nreturn_numpy: Necessary if using `use_gpu`. Specifies if a CuPy or\nNumPy array will be returned.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>UnitX, UnitY: 3D NumPy array, 3D NumPy array\n    x- and y-vector component in arrays\n</code></pre>\n", "parameters": ["direction", "use_gpu", "return_numpy"], "funcdef": "def"}, {"fullname": "SLIX.visualization", "modulename": "SLIX.visualization", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "SLIX.visualization.downsample", "modulename": "SLIX.visualization", "qualname": "downsample", "type": "function", "doc": "<p>Reduce image dimensions of a parameter map by replacing (N x N) pixels by\ntheir median value for each image. Image pixels with undefined values\n(background) will not be considered for computing the median,\nexcept when the fraction of background pixels lies above the defined\nthreshold.</p>\n\n<p>Args:</p>\n\n<pre><code>image: 2D or 3D parameter map (single image or image stack) calculated with\n SLIX.toolbox.\n\nkernel_size: Downsampling parameter N (defines how many image pixels\n(N x N) are replaced by their median value).\n\nbackground_value: Background value of the parameter map. This is generally\n-1 but can differ for unit vector maps.\n\nbackground_threshold: Fraction of background pixels in the considered\n(N x N) area for which the image pixels are set to background_value.\nIf the fraction of background pixels lies above this defined threshold,\nbackground pixels will not be considered for computing the median.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>2D or 3D NumPy array with reduced image dimensions.\n</code></pre>\n", "parameters": ["image", "kernel_size", "background_value", "background_threshold"], "funcdef": "def"}, {"fullname": "SLIX.visualization.visualize_parameter_map", "modulename": "SLIX.visualization", "qualname": "visualize_parameter_map", "type": "function", "doc": "<p>This method will create a Matplotlib plot based on imshow to display the\ngiven parameter map in different colors. The parameter map is plotted to\nthe current axis and figure. If neither is given, the method will\ncreate a new subfigure. To show the results, please use pyplot.show().</p>\n\n<p>Args:</p>\n\n<pre><code>parameter_map: 2D parameter map calculated with SLIX.toolbox.\n\nfig: Matplotlib figure. If None, a new subfigure will be created for fig\nand ax.\n\nax: Matplotlib axis. If None, a new subfigure will be created for fig\nand ax.\n\nalpha: Apply alpha to Matplotlib plots to overlay them with some other\nimage like the averaged transmitted light intensity.\n\ncmap: Matplotlib color map which is used for displaying the image.\n\nvmin: Minimum value in the resulting plot. If any value is below vmin,\nit will be displayed in black.\n\nvmax: Maximum value in the resulting plot. If any value is above vmax,\nit will be displayed in white.\n\ncolorbar: Boolean value controlling if a color bar will be displayed in\nthe current subplot.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>The current Matplotlib figure and axis. The image can be shown with\npyplot.show().\n</code></pre>\n", "parameters": ["parameter_map", "fig", "ax", "alpha", "cmap", "vmin", "vmax", "colorbar"], "funcdef": "def"}, {"fullname": "SLIX.visualization.visualize_unit_vectors", "modulename": "SLIX.visualization", "qualname": "visualize_unit_vectors", "type": "function", "doc": "<p>This method will create a Matplotlib plot based on quiver to represent the\ngiven unit vectors as colored lines (vector map).\nParameters like thinout can be used to reduce the computing load. If\nthinout = 1, the resulting vectors might not be visible\nwithout zooming in significantly. Here, the vectors will only be plotted\nto the current axis. To show the results, please use pyplot.show().</p>\n\n<p>Args:</p>\n\n<pre><code>UnitX: Unit vector components along the x-axis (3D NumPy array).\n\nUnitY: Unit vector components along the y-axis (3D NumPy array).\n\nthinout: Downsampling parameter N (defines how many vectors N x N are\nreplaced by one vector using the downsample function).\nUnit vectors will be thinned out using downsampling and thinning in\ncombination. This will increase the\nvector size in the resulting image but will also reduce the information\ndensity. Please use with caution.\n\nax: Matplotlib axis. If None, the current context axis will be used.\n\nalpha: Apply alpha to Matplotlib plots to overlay them with some other\nother image like the averaged transmitted light intensity.\nbackground_threshold: If the fraction of background pixels (number of\npixels without vector within N x N pixels) is below this threshold,\nthe downsampled pixel will not show a vector.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>The current Matplotlib axis. The image can be shown with pyplot.show().\n</code></pre>\n", "parameters": ["UnitX", "UnitY", "thinout", "ax", "alpha", "background_threshold"], "funcdef": "def"}, {"fullname": "SLIX.visualization.visualize_direction", "modulename": "SLIX.visualization", "qualname": "visualize_direction", "type": "function", "doc": "<p>Generate a 2D colorized direction image in the HSV color space based on\nthe original direction. Value and saturation of the color will always be\none. The hue is determined by the direction.</p>\n\n<p>If the direction parameter is only a 2D numpy array, the result will be\na simple orientation map where each pixel contains the HSV value\ncorresponding to the direction angle.</p>\n\n<p>When a 3D stack with max. three directions is used, the result will be\ndifferent. The resulting image will have two times the width and height.\nEach 2x2 square will show the direction angle of up to three directions.\nDepending on the number of directions, the following pattern is used to\nshow the different direction angles.</p>\n\n<p>1 direction:</p>\n\n<pre><code>1 1\n1 1\n</code></pre>\n\n<p>2 directions:</p>\n\n<pre><code>1 2\n2 1\n</code></pre>\n\n<p>3 directions:</p>\n\n<pre><code>1 2\n3 0\n</code></pre>\n\n<p>Args:</p>\n\n<pre><code>direction: 2D or 3D Numpy array containing the direction of the image\n           stack\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>numpy.ndarray: 2D image containing the resulting HSV orientation map\n</code></pre>\n", "parameters": ["direction"], "funcdef": "def"}]